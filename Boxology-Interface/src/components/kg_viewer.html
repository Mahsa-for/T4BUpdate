<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Boxology Knowledge Graph</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    html, body { height:100%; margin:0; padding:0; }
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #f3f4f6; display: flex; height: 100vh; }
    #toolbar {
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 48px;
      background: #2563eb;
      color: #fff;
      display: flex;
      align-items: center;
      padding: 0 24px;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      font-size: 18px;
      letter-spacing: 0.5px;
    }
    #toolbar .hint {
      font-size: 13px;
      color: #dbeafe;
      margin-left: 18px;
      font-weight: 400;
    }
    #main {
      display: flex;
      flex: 1;
      width: 100vw;
      height: 100vh;
      margin-top: 48px;
    }
    svg {
      flex: 1;
      background: linear-gradient(120deg, #f3f4f6 0%, #e0e7ef 100%);
      border-right: 1px solid #e5e7eb;
      height: 100%;
      width: 100%;
      cursor: grab;
      transition: background 0.3s;
    }
    .node circle {
      stroke: #fff;
      stroke-width: 2.2px;
      filter: drop-shadow(0 1px 2px #0001);
      transition: r 0.2s, filter 0.2s;
    }
    .node:hover circle {
      stroke: #2563eb;
      stroke-width: 3px;
      filter: drop-shadow(0 2px 6px #2563eb33);
      r: 13;
    }
    .node text {
      font-size: 13px;
      font-weight: 500;
      fill: #222;
      pointer-events: none;
      text-shadow: 0 1px 2px #fff8;
    }
    .link {
      stroke: #a3a3a3;
      stroke-width: 1.7px;
      opacity: 0.7;
      transition: stroke 0.2s;
    }
    .edge-label {
      font-size: 11px;
      fill: #64748b;
      pointer-events: none;
      font-family: 'Segoe UI', Arial, sans-serif;
      opacity: 0.85;
      background: #fff;
    }
    #panel {
      width: 340px;
      background: #fff;
      border-left: 1px solid #e5e7eb;
      padding: 24px 20px 20px 20px;
      box-shadow: -2px 0 8px #0001;
      font-size: 15px;
      overflow-y: auto;
      transition: box-shadow 0.2s;
      display: flex;
      flex-direction: column;
      min-width: 260px;
    }
    #panel h3 {
      margin: 0 0 8px 0;
      font-size: 1.25em;
      color: #2563eb;
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    #panel p {
      margin: 0 0 8px 0;
      color: #444;
    }
    #panel pre {
      background: #f3f4f6;
      border-radius: 6px;
      padding: 10px;
      font-size: 13px;
      color: #374151;
      margin-top: 10px;
      overflow-x: auto;
    }
    /* Node colors by rootType (case-sensitive, matches shapeTypesTree) */
.Boxology circle         { fill: #111827; }
.DesignPattern circle    { fill: #2563eb; }
.ProcessNode circle      { fill: #f97316; }
.Node circle             { fill: #22c55e; }

.Actor circle            { fill: #a21caf; }
.Data circle             { fill: #22c55e; }
.Symbol circle           { fill: #eab308; }
.Model circle            { fill: #0ea5e9; }
.Transform circle        { fill: #14b8a6; }
.Deduce circle           { fill: #fbbf24; }
.Train circle            { fill: #f43f5e; }
.Engineer circle         { fill: #64748b; }
.comment circle          { fill: #64748b; }

/* Model subclasses (optional, for more granularity) */
.InductiveModel circle           { fill: #38bdf8; }
.NeuralModel circle              { fill: #f472b6; }
.SemanticModel circle            { fill: #6366f1; }
.StatisticalModel circle         { fill: #f59e42; }
.NumericModel circle             { fill: #06b6d4; }
.SymbolicLearningModel circle    { fill: #fbbf24; }
.NeuralNetwork circle            { fill: #f472b6; }
.CNN circle                      { fill: #fca5a5; }
.RNN circle                      { fill: #fcd34d; }
.LSTM circle                     { fill: #fde68a; }
.GRU circle                      { fill: #fef08a; }
.Transformer circle              { fill: #a5b4fc; }
.DecoderOnlyTransformer circle   { fill: #818cf8; }
.EncoderDecoderTransformer circle{ fill: #6366f1; }
.EncoderOnlyTransformer circle   { fill: #818cf8; }
.GNN circle                      { fill: #4ade80; }
.GCN circle                      { fill: #22d3ee; }
.GAT circle                      { fill: #38bdf8; }
.SupervisedGraphNNModel circle   { fill: #0ea5e9; }
.LLM circle                      { fill: #f472b6; }
.OWLOntology circle              { fill: #a3e635; }
.RDFModel circle                 { fill: #bef264; }
.RDFSModel circle                { fill: #d9f99d; }
.RuleBasedModel circle           { fill: #fde68a; }
.SHACLShapesModel circle         { fill: #fbbf24; }
.RegressionModel circle          { fill: #f59e42; }
.ClassificationModel circle      { fill: #fbbf24; }
.ClusteringModel circle          { fill: #fcd34d; }
.FuzzyModel circle               { fill: #fef08a; }

/* Data subclasses */
.Number circle                   { fill: #a3e635; }
.Dataset circle                  { fill: #bef264; }
.Tensor circle                   { fill: #d9f99d; }
.Text circle                     { fill: #fca5a5; }
.Image circle                    { fill: #fcd34d; }
.Audio circle                    { fill: #818cf8; }
.Video circle                    { fill: #a5b4fc; }
.TimeSeries circle               { fill: #fbbf24; }

/* Symbol subclasses */
.DB circle                       { fill: #fbbf24; }
.KG circle                       { fill: #f59e42; }
.Label circle                    { fill: #fca5a5; }
.Trace circle                    { fill: #818cf8; }
.Rules circle                    { fill: #fde68a; }

/* Actor subclasses */
.Human circle                    { fill: #f472b6; }
.Robot circle                    { fill: #a21caf; }
    /* Scrollbar for panel */
    #panel::-webkit-scrollbar { width: 8px; background: #f3f4f6; }
    #panel::-webkit-scrollbar-thumb { background: #e5e7eb; border-radius: 4px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <span style="font-weight:700; font-size:20px; letter-spacing:1px;">ðŸ§  Boxology Knowledge Graph</span>
    <span class="hint">Drag nodes â€¢ Zoom â€¢ Click for details â€¢ Hover for highlight</span>
  </div>
  <div id="main">
    <svg></svg>
    <div id="panel"><b>Click a node</b></div>
  </div>
<script>
const shapeTypesTree = {
  Actor: { Human: null, Robot: null },
  Data: { Number: null, Dataset: null, Tensor: null, Text: null, Image: null, Audio: null, Video: null, TimeSeries: null },
  Symbol: { DB: null, KG: null, Label: null, Trace: null, Rules: null },
  Model: {
    InductiveModel: {
      NumericModel: null,
      SymbolicLearningModel: {
        SelfSupervisedRuleMiningModel: {
          AxiomMiningModel: null
        },
        UnsupervisedCommunityDetectionModel: null
      }
    },
    NeuralModel: {
      NeuralNetwork: {
        CNN: null,
        RNN: { LSTM: null, GRU: null },
        Transformer: {
          DecoderOnlyTransformer: null,
          EncoderDecoderTransformer: null,
          EncoderOnlyTransformer: null
        },
        GNN: {
          GCN: null,
          GAT: null,
          SupervisedGraphNNModel: null
        }
      },
      LLM: null
    },
    SemanticModel: {
      OWLOntology: null,
      RDFModel: null,
      RDFSModel: null,
      RuleBasedModel: null,
      SHACLShapesModel: null
    },
    StatisticalModel: {
      RegressionModel: null,
      ClassificationModel: null,
      ClusteringModel: null,
      FuzzyModel: null
    }
  },
  Transform: null,
  Deduce: null,
  Train: null,
  Engineer: null,
  comment: null,
};

// Recursively search the tree for a label and return the root type
function getRootType(label, tree = shapeTypesTree, root = null) {
  for (const key in tree) {
    if (key.toLowerCase() === label.toLowerCase()) return root || key;
    const subtree = tree[key];
    if (subtree && typeof subtree === "object") {
      const found = getRootType(label, subtree, root || key);
      if (found) return found;
    }
  }
  return null;
}

function addTypedNode(obj) {
  const label = obj.name || obj.label || "";
  const rootType = getRootType(label) || "data";
  return {
    id: obj.id,
    label: obj.label,
    type: label,
    rootType: rootType,
    meta: obj
  };
}
const params = new URLSearchParams(window.location.search);
const blobUrl = params.get('blob');
fetch(blobUrl).then(r=>r.json()).then(raw=>{
  const nodes = {};
  const edges = [];
  const box = raw.boxologies[0];
  nodes[box.id] = {id: box.id, label: box.label, type: "Boxology", rootType: "Boxology", meta: box};

  for(const dp of box.DesignPattern) {
    nodes[dp.id] = {id: dp.id, label: dp.label, type: "DesignPattern", rootType: "DesignPattern", meta: dp};
    edges.push({source: box.id, target: dp.id, type: "hasPattern"});

    if(dp.input) for(const inp of dp.input) {
      nodes[inp.id] = addTypedNode(inp);
      edges.push({source: dp.id, target: inp.id, type: "hasInput"});
    }
    if(dp.process) {
      nodes[dp.process.id] = addTypedNode(dp.process);
      edges.push({source: dp.id, target: dp.process.id, type: "hasProcess"});
    }
    if(dp.output) for(const out of dp.output) {
      nodes[out.id] = addTypedNode(out);
      edges.push({source: dp.id, target: out.id, type: "hasOutput"});
    }
  }

  const nodeArr = Object.values(nodes);

  const svg = d3.select("svg");
  const width = window.innerWidth - 340;
  const height = window.innerHeight - 48;
  svg.attr("width", width).attr("height", height);

  const g = svg.append("g");
  svg.call(d3.zoom().on("zoom", e => g.attr("transform", e.transform)));

  const sim = d3.forceSimulation(nodeArr)
    .force("link", d3.forceLink(edges).id(d=>d.id).distance(110))
    .force("charge", d3.forceManyBody().strength(-320))
    .force("center", d3.forceCenter(width/2, height/2))
    .force("collide", d3.forceCollide(28));

  const link = g.selectAll(".link")
    .data(edges)
    .join("line")
    .attr("class","link");

  const node = g.selectAll(".node")
    .data(nodeArr)
    .join("g")
    .attr("class", d => "node " + (d.rootType || d.type))
    .call(d3.drag()
      .on("start", dragStart)
      .on("drag", drag)
      .on("end", dragEnd)
    )
    .on("click", showDetails)
    .on("mouseover", function() {
      d3.select(this).raise().select("circle").attr("r", 15);
    })
    .on("mouseout", function() {
      d3.select(this).select("circle").attr("r", 11);
    });

  node.append("circle").attr("r", 11);

  node.append("text")
    .attr("x", 16)
    .attr("y", 5)
    .text(d => d.label);

  const edgeLabel = g.selectAll(".edge-label")
    .data(edges)
    .join("text")
    .attr("class", "edge-label")
    .attr("font-size", 11)
    .attr("fill", "#888")
    .attr("text-anchor", "middle")
    .text(d => d.type);

  sim.on("tick", ()=>{
    link
      .attr("x1",d=>d.source.x)
      .attr("y1",d=>d.source.y)
      .attr("x2",d=>d.target.x)
      .attr("y2",d=>d.target.y);

    node.attr("transform", d => `translate(${d.x},${d.y})`);

    edgeLabel
      .attr("x", d => (d.source.x + d.target.x) / 2)
      .attr("y", d => (d.source.y + d.target.y) / 2);
  });

  function showDetails(e, d){
    // Clarification mapping for root types and common subclasses
    const clarifications = {
      Boxology: "A Boxology diagram describing a neuro-symbolic architecture.",
      DesignPattern: "A reusable pattern or building block in the Boxology framework.",
      ProcessNode: "A process or operation (e.g., Train, Deduce, Transform) in the workflow.",
      Node: "A generic node in the knowledge graph.",
      Actor: "An agent that acts in the system, such as a Human or Robot.",
      Data: "A data artifact, such as Number, Text, Image, etc.",
      Symbol: "A symbolic artifact, such as Label, Trace, Rules, or Knowledge Graph.",
      Model: "A model, such as Neural, Semantic, or Statistical models.",
      Transform: "A transformation operation (e.g., embedding, normalization, aggregation).",
      Deduce: "A deduction or inference operation.",
      Train: "A training operation for models.",
      Engineer: "An engineering or design operation.",
      comment: "A comment or annotation node.",
      // Subclasses (examples)
      Human: "A human actor in the system.",
      Robot: "A robot actor in the system.",
      Number: "A numeric data value.",
      Text: "A text data artifact.",
      Image: "An image data artifact.",
      Audio: "An audio data artifact.",
      Video: "A video data artifact.",
      TimeSeries: "A time series data artifact.",
      DB: "A database symbol.",
      KG: "A knowledge graph symbol.",
      Label: "A label or annotation symbol.",
      Trace: "A trace or log symbol.",
      Rules: "A set of symbolic rules.",
      NeuralModel: "A neural network-based model.",
      SemanticModel: "A semantic or ontology-based model.",
      StatisticalModel: "A statistical or probabilistic model.",
      InductiveModel: "A model that learns from data.",
      // ...add more as needed...
    };

    // Prefer clarification for type, then rootType, else fallback
    const explanation = clarifications[d.type] || clarifications[d.rootType] || "No further description available.";

    document.getElementById("panel").innerHTML =
      `<h3>${d.label}</h3>
       <p><b>Type:</b> ${d.type} <span style="color:#888">(root: ${d.rootType})</span></p>
       <p style="color:#2563eb; margin-bottom:10px;">${explanation}</p>
       <pre>${JSON.stringify(d.meta, null, 2)}</pre>`;
  }

  function dragStart(e,d){ if(!e.active) sim.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
  function drag(e,d){ d.fx=e.x; d.fy=e.y; }
  function dragEnd(e,d){ if(!e.active) sim.alphaTarget(0); d.fx=null; d.fy=null; }
});
</script>
</body>
</html>
